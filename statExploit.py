# -*- coding: utf-8 -*-

"""
Statistical processing of metricData saved on .npz files
This script processes metric data and questionnaire results from every trial by every subject on one given control mode, and performs comparison tests
WARNING: The same number of trials per control mode is needed
"""

# Scientific calculus utilities
import numpy as np                  # Basic array structures
import scipy.stats as stat          # Statistical functions and tests
import matplotlib.pyplot as plt     # Plotting tools

import os.path

def readFile(inputFile, container):
    """Reads metrics data from the given input file
    :param string inputFile: Path to the input file to read
    :param list container: List where to append the read and formated data.
    :returns: The same container with appended metrics data. If the container was empty at first, metrics names are appended as the first element.
    """
    # Load from file
    data = np.load(inputFile)
    metricData = data['metricData']
    data.close()

    # Reformat into a np.array
    nTrials = metricData.shape[0]
    nMetrics = len(metricData.dtype.names)
    metricArray = np.zeros((nMetrics, nTrials))
    for i, n in enumerate(metricData.dtype.names):
        metricArray[i, :] = metricData[n]

    if len(container) < 1:
        container.append(metricData.dtype.names)
    container.append(metricArray)

    return container

def browseForFiles(mode = 'pos'):
    """Browses the data folder looking for metrics data files, and generates an array to format and stock retrieved data
    :param string mode: Control mode identifier
    :returns: Tuple comprising the list of metrics' names and the nMetrics.nSubjects.nTrials shape array
    """
    # Look for every file named 'Metrics.npz' in the current folder and all its subfolders, and put their data in a list
    container = []
    for root, dirs, files in os.walk('.\\set1\\{}\\'.format(mode) ): 
        for name in files:
            if name == 'Metrics.npz':
                readFile(os.path.join(root, name), container)

    # Reformat data into one array
    if len(container) > 0:
        names = container[0]
        array = np.zeros( (len(names), len(container) - 1, len(container[1][0]) ) )
        array[:, 0, :] = container[1]

        if len(container) > 2:
            for i in range(2, len(container) ):
                array[:, i - 1, :] = container[i]

        return names, array

    else:
        print('No value retrieved for mode: {}'.format(mode) )
        return [], []

def autolabel(rects):
    # Attach some text labels on bar plots
    for rect in rects:
        width = rect.get_width()
        ax.text(rect.get_x() + 0.5 * width, rect.get_y() + 0.45 * rect.get_height(), '{:.3}'.format(width), ha = 'center', va = 'bottom')


if __name__ == '__main__':
    
    nGroups = 3
    groupNames = ['Pos', 'Vel', 'Vel2']

    # Text messages describing the results
    valn = 'Null hypothesis validated: the samples follow a normal distribution.'
    rejn = 'Null hypothesis rejected: the samples\' distribution significantly differ from a normal distribution.'

    valv = 'Null hypothesis validated: the groups don\'t have significantly different variances.'
    rejv = 'Null hypothesis rejected: at least two groups have significantly different variances.'

    valg = 'Null hypothesis validated: the groups don\'t have significantly different means.'
    rejg = 'Null hypothesis rejected: at least two groups have significantly different means.'
    
    rejm = 'Null hypothesis rejected: the two groups have significantly different means.'
    
    # Load and format data
    nPos, dPos = browseForFiles('pos')
    nVel, dVel = browseForFiles('vel')
    nVel2, dVel2 = browseForFiles('vel2')
    
    mask = [True] * 15 + [False, True, True, False, True]
    indMask = np.where(mask)[0]
    nSubjects = mask.count(True)
    
    namesOK = (nPos == nVel) and (nVel == nVel2) # If the metrics' names are the same (and that SHOULD be the case)
    shapesOK = (dPos.shape == dVel.shape) and (dVel.shape == dVel2.shape)
    
    if namesOK and shapesOK:
        nMetrics = dPos.shape[0]
        nTrials = dPos.shape[2]

        vPos = dPos[:, indMask, :].reshape( (nMetrics, nSubjects * nTrials) )
        vVel = dVel[:, indMask, :].reshape( (nMetrics, nSubjects * nTrials) )
        vVel2 = dVel2[:, indMask, :].reshape( (nMetrics, nSubjects * nTrials) )

        print('Number of subjects: {}\nNumber of samples: {}\nMetrics: {}'.format(nSubjects, nSubjects * nTrials, nPos) )
        for i, n in enumerate(nPos): # For every available metrics type
            print('\n\n{} analysis:\n'.format(n) )

            samplesPos = vPos[i, :]
            samplesVel = vVel[i, :]
            samplesVel2 = vVel2[i, :]
            samplesAll = np.array([samplesPos, samplesVel, samplesVel2])

            # Test for normality of samples
            (T, pn) = stat.normaltest(samplesAll, axis = 1)
            for name, p in zip(groupNames, pn):
                print('\nTesting group {} normality: p-value = {}\n{}'.format(name, p, valn if p > 0.05 else rejn) )

            # Test for homoscedasticity between groups, the test depending on the apparent normality of the samples
            (vtest, name) = (stat.bartlett, 'Bartlett') if np.all(pn > 0.05) else (stat.levene, 'Levene')
            (V, pv) = vtest(samplesPos, samplesVel, samplesVel2)
            print('\nComparing groups\' variances with {} test: p-value = {}\n{}'.format(name, pv, valv if pv > 0.05 else rejv) )

            # Test for equality of means and medians between groups
            (F, pf) = stat.f_oneway(samplesPos, samplesVel, samplesVel2)
            (H, ph) = stat.kruskal(samplesPos, samplesVel, samplesVel2)
            print('\nComparing groups\' means with parametric ANOVA test: p-value = {}\n{}'.format(pf, valg if pf > 0.05 else rejg) )
            print('\nComparing groups\' medians with non-parametric Kruskal test: p-value = {}\n{}'.format(ph, valg if ph > 0.05 else rejg) )

            # Plot the mean and standard deviation of each group on the same figure
            # This kind of plot greatly helps identifying the possible differences between groups
            means = np.mean(samplesAll, axis=1)
            sds = np.std(samplesAll, axis = 1)

            fig = plt.figure()
            ax = fig.add_subplot(1, 1, 1)
            ind = np.arange(nGroups)
            plots = ax.errorbar(ind, means, fmt = 'o-', yerr = sds)
            ax.set_xlim(-0.5, nGroups - 0.5)
            ax.set_xlabel('Groups')
            ax.set_xticks(ind)
            ax.set_xticklabels(groupNames)
#            ax.set_ylim(min(0, np.min(means - sds) - 0.5), np.max(means + sds) + 0.5 )
            ax.set_ylabel(n)
            ax.set_title('Evolution of {} values between groups'.format(n) )
            ax.legend( (plots[0], plots[2]), ('Mean value', 'Standard deviation'), bbox_to_anchor=(0, 1), loc = 2, borderaxespad = 0.)
            
            if pf <= 0.05 or ph <= 0.05 : # Compare the groups two by two                
                (Tab, pab) = stat.wilcoxon(samplesPos, samplesVel)
                print('\nComparing Pos and Vel groups\' means with Wilcoxon test: p-value = {}\n{}'.format(pab, valg if pab > 0.05 else rejm) )
                (Tac, pac) = stat.wilcoxon(samplesPos, samplesVel2)
                print('Comparing Pos and Vel2 groups\' means with Wilcoxon test: p-value = {}\n{}'.format(pac, valg if pac > 0.05 else rejm) )
                (Tbc, pbc) = stat.wilcoxon(samplesVel, samplesVel2)
                print('Comparing Vel and Vel2 groups\' means with Wilcoxon test: p-value = {}\n{}'.format(pbc, valg if pbc > 0.05 else rejm) )
            
            if n == 'S':
                nTargets = samplesPos.shape[0] / nSubjects
                rates = np.mean(samplesAll.reshape((3, nSubjects, nTargets)), axis = 2)
                fig = plt.figure()
                ax = fig.add_subplot(1, 1, 1)
                ind = np.arange(nGroups)
                ax.boxplot(rates.T)
                ax.set_xlabel('Groups')
                ax.set_xticklabels(groupNames)
                ax.set_ylim(min(0, np.min(rates) - 0.1), np.max(rates) + 0.1 )
                ax.set_ylabel('Success rate')
                ax.set_title('Distribution of success rates between groups')

#            plt.show() # Show the last plot and wait for the window to be closed
    
    else:
        raise ValueError('Metrics\' names don\'t match between loaded values! Check for discrepancies in the data type.')
    
    # Results of the adapted SUS questionnaire
    print('\n\nQuestionnaire results - SUS score')
    resFull = np.array([ [62.5, 57.5, 80, 80, 70, 40, 77.5, 12.5, 77.5, 82.5, 55, 17.5, 15, 77.5, 20, 25, 70, 50, 22.5, 37.5],
                        [77.5, 85, 82.5, 95, 95, 82.5, 85, 77.5, 67.5, 95, 80, 77.5, 67.5, 77.5, 80, 25, 47.5, 55, 10, 75],
                        [80, 85, 55, 95, 87.5, 80, 77.5, 85, 85, 97.5, 80, 70, 52.5, 77.5, 87.5, 10, 60, 47.5, 27.5, 82.5] ])
    
    resAll = resFull[:, indMask]
    resPos = resAll[0, :]
    resVel = resAll[1, :]
    resVel2 = resAll[2, :]
    
    # Test for normality of samples
    (T, pn) = stat.normaltest(resAll, axis = 1)
    for name, p in zip(groupNames, pn):
        print('\nTesting group {} normality: p-value = {}\n{}'.format(name, p, valn if p > 0.05 else rejn) )

    # Test for homoscedasticity between groups, the test depending on the apparent normality of the samples
    (vtest, name) = (stat.bartlett, 'Bartlett') if np.all(pn > 0.05) else (stat.levene, 'Levene')
    (V, pv) = vtest(resPos, resVel, resVel2)
    print('\nComparing groups\' variances with {} test: p-value = {}\n{}'.format(name, pv, valv if pv > 0.05 else rejv) )

    # Test for equality of medians between groups
    (H, ph) = stat.kruskal(resPos, resVel, resVel2)
    print('\nComparing groups\' medians with non-parametric Kruskal-Wallis test: p-value = {}\n{}'.format(ph, valg if ph > 0.05 else rejg) )
    
    # Plot the mean and standard deviation of each group on the same figure
    # This kind of plot greatly helps identifying the possible differences between groups
    means = np.mean(resAll, axis = 1)
    sds = np.std(resAll, axis = 1)

    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    ind = np.arange(nGroups)
    plots = ax.errorbar(ind, means, fmt = 'o-', yerr = sds)
    ax.set_xlim(-0.5, nGroups - 0.5)
    ax.set_xlabel('Groups')
    ax.set_xticks(ind)
    ax.set_xticklabels(groupNames)
    ax.set_ylabel('Total SUS score')
    ax.set_title('SUS results values between groups')
    ax.legend( (plots[0], plots[2]), ('Mean value', 'Standard deviation'), bbox_to_anchor=(0, 1), loc = 2, borderaxespad = 0.)
    
    (Tab, pab) = stat.wilcoxon(resPos, resVel)
    print('\nComparing Pos and Vel scores\' means with Wilcoxon test: p-value = {}\n{}'.format(pab, valg if pab > 0.05 else rejm) )
    (Tac, pac) = stat.wilcoxon(resPos, resVel2)
    print('Comparing Pos and Vel2 scores\' means with Wilcoxon test: p-value = {}\n{}'.format(pac, valg if pac > 0.05 else rejm) )
    (Tbc, pbc) = stat.wilcoxon(resVel, resVel2)
    print('Comparing Vel and Vel2 scores\' means with Wilcoxon test: p-value = {}\n{}'.format(pbc, valg if pbc > 0.05 else rejm) )
    
    
    # Results on the second part of the questionnaire
    print('\n\nQuestionnaire results - individual questions from the second part')
    scoresP2 = np.array([
        [ [3, 2, 5, 3, 2, 1, 4, 1, 4, 3, 4, 2, 1, 4, 2, 3, 3, 2, 2, 5], # Q11
          [4, 3, 4, 4, 4, 4, 4, 4, 3, 4, 5, 3, 3, 3, 4, 2, 3, 3, 1, 3],
          [4, 3, 3, 4, 3, 5, 3, 4, 5, 5, 4, 5, 2, 4, 4, 2, 2, 1, 3, 4] ],
        
        [ [2, 4, 1, 3, 3, 4, 1, 5, 2, 1, 2, 4, 4, 2, 4, 4, 3, 4, 2, 4], # Q12
          [2, 2, 1, 1, 2, 2, 2, 1, 3, 1, 1, 1, 2, 3, 2, 4, 3, 2, 5, 1],
          [2, 2, 3, 1, 3, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 5, 2, 3, 5, 2] ],
          
        [ [4, 4, 3, 3, 4, 3, 2, 5, 1, 2, 1, 3, 4, 3, 1, 4, 1, 4, 5, 4], # Q13
          [4, 2, 3, 2, 4, 3, 2, 1, 3, 2, 1, 4, 2, 3, 3, 4, 3, 3, 5, 2],
          [2, 4, 4, 3, 5, 3, 3, 2, 2, 1, 2, 2, 3, 3, 1, 4, 3, 3, 4, 2] ],

        [ [3, 2, 5, 3, 4, 2, 4, 1, 4, 5, 5, 2, 1, 5, 3, 2, 4, 2, 2, 2], # Q14
          [4, 4, 4, 4, 5, 5, 3, 4, 3, 5, 4, 4, 3, 2, 4, 1, 3, 3, 1, 3],
          [3, 3, 3, 4, 5, 4, 3, 4, 4, 5, 5, 4, 2, 4, 4, 1, 3, 2, 3, 4] ],

        [ [3, 4, 2, 2, 4, 5, 3, 5, 3, 4, 1, 4, 5, 3, 1, 4, 2, 3, 3, 5], # Q15
          [2, 3, 2, 2, 4, 1, 3, 2, 2, 1, 1, 1, 1, 2, 2, 4, 3, 3, 3, 2],
          [2, 4, 4, 2, 1, 1, 3, 1, 1, 1, 1, 3, 3, 3, 3, 5, 4, 3, 3, 1] ],

        [ [3, 4, 3, 1, 4, 4, 4, 5, 2, 3, 4, 4, 4, 4, 4, 2, 2, 3, 5, 5], # Q16
          [3, 2, 2, 1, 1, 4, 2, 1, 3, 1, 2, 2, 1, 3, 3, 3, 3, 3, 5, 3],
          [1, 2, 2, 1, 1, 3, 3, 2, 2, 1, 2, 1, 1, 3, 2, 3, 2, 3, 5, 3] ] ])
    
    nQuestions = len(scoresP2)
    
    fig = plt.figure()
    for i in range(nQuestions):
        print('\n\nQuestion {}'.format(11 + i) )
        
        qAll = scoresP2[i, :, indMask].T
        qPos = qAll[0, :]
        qVel = qAll[1, :]
        qVel2 = qAll[2, :]
        
        # Test for normality of samples
        (T, pn) = stat.normaltest(qAll, axis = 1)
        for name, p in zip(groupNames, pn):
            print('\nTesting group {} normality: p-value = {}\n{}'.format(name, p, valn if p > 0.05 else rejn) )
    
        # Test for homoscedasticity between groups, the test depending on the apparent normality of the samples
        (vtest, name) = (stat.bartlett, 'Bartlett') if np.all(pn > 0.05) else (stat.levene, 'Levene')
        (V, pv) = vtest(qPos, qVel, qVel2)
        print('\nComparing groups\' variances with {} test: p-value = {}\n{}'.format(name, pv, valv if pv > 0.05 else rejv) )
    
        # Test for equality of medians between groups
        (H, ph) = stat.kruskal(qPos, qVel, qVel2)
        print('\nComparing groups\' medians with non-parametric Kruskal-Wallis test: p-value = {}\n{}'.format(ph, valg if ph > 0.05 else rejg) )
        
        # Plot the mean and standard deviation of each group on the same figure
        # This kind of plot greatly helps identifying the possible differences between groups
        means = np.mean(qAll, axis = 1)
        sds = np.std(qAll, axis = 1)
    
        ax = fig.add_subplot(1, nQuestions, i + 1)
        ind = np.arange(nGroups)
        plots = ax.errorbar(ind, means, fmt = 'o-', yerr = sds)
        ax.set_xlim(-0.5, nGroups - 0.5)
        ax.set_xlabel('Groups')
        ax.set_xticks(ind)
        ax.set_xticklabels(groupNames)
        ax.set_ylabel('Score')
        ax.set_title('Question {} score'.format(11 + i) )
        ax.legend( (plots[0], plots[2]), ('Mean value', 'Standard deviation'), bbox_to_anchor=(0, 1), loc = 2, borderaxespad = 0.)
        
        (Tab, pab) = stat.wilcoxon(qPos, qVel)
        print('\nComparing Pos and Vel scores with Wilcoxon test: p-value = {}\n{}'.format(pab, valg if pab > 0.05 else rejm) )
        (Tac, pac) = stat.wilcoxon(qPos, qVel2)
        print('Comparing Pos and Vel2 scores with Wilcoxon test: p-value = {}\n{}'.format(pac, valg if pac > 0.05 else rejm) )
        (Tbc, pbc) = stat.wilcoxon(qVel, qVel2)
        print('Comparing Vel and Vel2 scores with Wilcoxon test: p-value = {}\n{}'.format(pbc, valg if pbc > 0.05 else rejm) )
    
    # Results of the preference orders
    rankA = np.array([13, 4, 1])
    rankB = np.array([4, 8, 6])
    rankC = np.array([1, 6, 11])
    
    if sum(rankA) == sum(rankB) and sum(rankA) == sum(rankC):
        nSubjects = sum(rankA)
        ind = np.arange(3)
        
        perA = rankA * 100. / nSubjects
        perB = rankB * 100. / nSubjects
        perC = rankC * 100. / nSubjects

        fig = plt.figure()
        ax = fig.add_subplot(1, 1, 1)
        bA = ax.barh(ind, perA, color = 'r', align = 'center', alpha = 0.4)
        bB = ax.barh(ind, perB, color = 'g', align = 'center', alpha = 0.4, left = perA)
        bC = ax.barh(ind, perC, color = 'b', align = 'center', alpha = 0.4, left = perA + perB)
        
        ax.set_xlim(0, 130)
        ax.set_xlabel('Percentage of subjects')
        ax.set_xticks(np.arange(0, 101, 10) )
        ax.set_ylabel('Preference position')
        ax.set_yticks(ind)
        ax.set_yticklabels(['Third', 'Second', 'First'])
        ax.set_title('Preference order by mode')
        ax.legend( (bA[0], bB[0], bC[0]), groupNames, bbox_to_anchor=(1, 1), loc = 1, borderaxespad = 0.)
        
        autolabel(bA)
        autolabel(bB)
        autolabel(bC)

    plt.show() # Display all pending figure windows
